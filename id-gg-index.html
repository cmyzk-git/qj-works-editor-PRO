<!DOCTYPE html>
<html lang="ja">
<head>
    <meta name="robots" content="noindex, nofollow">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- noindexの設定を追加 -->
    <meta name="robots" content="noindex, nofollow">
    <title>Voice Genesis v4.1.17 "Archive Edition"</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@500;700&family=Noto+Sans+JP:wght@400;700;900&display=swap');
        
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; cursor: crosshair; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .scanline {
            width: 100%; height: 2px;
            background: rgba(99, 102, 241, 0.2);
            position: absolute; top: 0; z-index: 10;
            pointer-events: none; animation: scan 4s linear infinite;
        }

        @keyframes scan { from { top: 0; } to { top: 100%; } }

        input[type="range"] { -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { background: rgba(30, 41, 59, 0.5); height: 2px; border-radius: 1px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; background: #6366f1; border-radius: 50%; margin-top: -5px; box-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }

        .archive-item { transition: transform 0.2s, background 0.2s; position: relative; border-left: 3px solid transparent; }
        .archive-item:hover { background: rgba(99, 102, 241, 0.1); }
        .active-specimen { background: rgba(99, 102, 241, 0.15) !important; border-left-color: #6366f1 !important; opacity: 1 !important; }
        
        .dragging { opacity: 0.4; transform: scale(0.98); background: rgba(99, 102, 241, 0.3) !important; }
        .drag-over { border-top: 2px solid #6366f1; }

        .record-pulse { animation: pulse-red 1.5s infinite; }
        @keyframes pulse-red { 
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .mic-active { animation: pulse-indigo 1s infinite; background: rgba(99, 102, 241, 0.3) !important; border-color: #6366f1 !important; }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen selection:bg-indigo-500/30" @dragover.prevent @drop.prevent>
    <div id="app" class="relative overflow-hidden">
        <div class="scanline"></div>
        
        <header class="p-4 border-b border-white/5 flex flex-wrap gap-4 justify-between items-center relative z-20">
            <div class="flex items-center gap-4">
                <div class="w-8 h-8 bg-indigo-600 rounded flex items-center justify-center shadow-[0_0_15px_rgba(79,70,229,0.4)]">
                    <i data-lucide="database" class="text-white w-4 h-4"></i>
                </div>
                <div>
                    <h1 class="text-xs font-black tracking-[0.3em] uppercase opacity-90">Voice Genesis <span class="text-indigo-400">Archive v4.1.17</span></h1>
                    <p class="text-[8px] text-slate-500 font-bold uppercase tracking-widest">{{ t.subtitle }}</p>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div class="flex bg-slate-900 border border-white/10 p-0.5 rounded-lg text-slate-500 text-[8px] font-mono px-2 uppercase tracking-tighter items-center mr-2">
                    MIC: {{ micStatus }} | AMBIENT: {{ ambientBuffer ? 'READY' : 'NONE' }}
                </div>
                <div class="flex bg-slate-900 border border-white/10 p-0.5 rounded-lg">
                    <button @click="lang = 'en'" :class="['px-2 py-1 text-[9px] font-black rounded transition-all', lang === 'en' ? 'bg-indigo-600 text-white' : 'text-slate-500 hover:text-slate-300']">EN</button>
                    <button @click="lang = 'jp'" :class="['px-2 py-1 text-[9px] font-black rounded transition-all', lang === 'jp' ? 'bg-indigo-600 text-white' : 'text-slate-500 hover:text-slate-300']">JP</button>
                </div>
                
                <div v-if="isRecording" class="px-3 py-1 bg-red-600 border border-red-400 rounded text-[9px] font-mono text-white uppercase tracking-widest record-pulse">REC</div>
                <div v-if="isSequenceMode" :class="['px-3 py-1 border rounded text-[9px] font-mono uppercase tracking-widest', isRecording ? 'bg-red-600/20 border-red-500/50 text-red-400' : 'bg-amber-600/20 border-amber-500/50 text-amber-400']">
                    {{ isRecording ? t.seqRender : t.seqPreview }} {{ sequenceLoop ? '∞' : '1x' }}
                </div>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-12 gap-0 min-h-[calc(100vh-65px)]">
            <!-- Specimen List -->
            <aside class="lg:col-span-3 border-r border-white/5 bg-slate-900/20 flex flex-col relative h-[calc(100vh-65px)] overflow-hidden">
                <div class="p-4 border-b border-white/5 bg-slate-900/40 space-y-2">
                    <h2 class="text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-1 flex items-center gap-2">
                        <i data-lucide="archive" class="w-3 h-3"></i> {{ t.archiveTitle }}
                    </h2>
                    <div class="grid grid-cols-2 gap-2">
                        <input type="file" id="audio-upload" class="hidden" @change="handleFileUpload" accept="audio/*" multiple>
                        <label for="audio-upload" class="flex items-center justify-center gap-2 p-2 bg-indigo-600/10 hover:bg-indigo-600/20 border border-indigo-500/20 rounded-lg text-[9px] font-black cursor-pointer transition-all">
                            <i data-lucide="plus-circle" class="w-3 h-3 text-indigo-400"></i> {{ t.importBtn }}
                        </label>
                        <button @click="toggleLiveMic" :class="['flex items-center justify-center gap-2 p-2 border rounded-lg text-[9px] font-black transition-all', isMicSampling ? 'mic-active bg-indigo-600 text-white border-indigo-400' : 'bg-indigo-600/10 hover:bg-indigo-600/20 border-indigo-500/20 text-indigo-100']">
                            <i :data-lucide="isMicSampling ? 'mic-off' : 'mic'" class="w-3 h-3 text-indigo-400" :class="isMicSampling ? 'text-white' : ''"></i> {{ isMicSampling ? t.stopMicBtn : t.liveMicBtn }}
                        </button>
                    </div>
                </div>

                <!-- Ambient Layer Control (Drop Zone) -->
                <div class="p-4 bg-emerald-500/5 border-b border-white/5 space-y-3"
                    @dragover.prevent="isDraggingAmbient = true" @dragenter.prevent="isDraggingAmbient = true" 
                    @dragleave.prevent="isDraggingAmbient = false" @drop.prevent.stop="handleAmbientDrop">
                    <div class="flex justify-between items-center">
                        <h3 class="text-[9px] font-black text-emerald-500 uppercase tracking-widest flex items-center gap-2">
                            <i data-lucide="wind" class="w-3 h-3"></i> {{ t.ambientLayer }}
                        </h3>
                        <div v-if="ambientBuffer" class="flex gap-2">
                            <button @click="toggleAmbient" :class="['p-1 rounded transition-colors', isAmbientPlaying ? 'text-emerald-400' : 'text-slate-600']">
                                <i :data-lucide="isAmbientPlaying ? 'pause-circle' : 'play-circle'" class="w-4 h-4"></i>
                            </button>
                            <button @click="clearAmbient" class="text-slate-600 hover:text-red-400 p-1">
                                <i data-lucide="x-circle" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div v-if="!ambientBuffer" class="relative">
                        <input type="file" id="ambient-upload" class="hidden" @change="handleAmbientUpload" accept="audio/*">
                        <label for="ambient-upload" 
                            :class="['block w-full py-3 border border-dashed rounded-lg text-[8px] text-center transition-all cursor-pointer font-black uppercase tracking-widest', 
                            isDraggingAmbient ? 'bg-emerald-500/20 border-emerald-400 text-emerald-400' : 'border-emerald-500/30 text-emerald-500/60 hover:text-emerald-400 hover:bg-emerald-500/10']">
                            {{ isDraggingAmbient ? t.dropRelease : t.addAmbientBtn }}
                        </label>
                    </div>

                    <div v-else class="space-y-2">
                        <div class="flex justify-between items-center text-[8px] font-mono text-emerald-400/80 uppercase">
                            <span class="truncate pr-4">{{ ambientName }}</span>
                            <span>{{ ambientVolume }}%</span>
                        </div>
                        <input type="range" v-model.number="ambientVolume" min="0" max="100" @input="updateAmbientVolume" class="w-full h-1 bg-emerald-900/30 rounded-full appearance-none">
                    </div>
                </div>
                
                <div class="flex-1 overflow-y-auto" @dragover.prevent @drop="onArchiveListDrop">
                    <div v-if="archives.length === 0" class="p-12 text-center opacity-20 italic text-[10px] uppercase tracking-widest leading-loose">
                        {{ t.noSpecimen }}
                    </div>
                    <div v-for="(item, idx) in archives" :key="item.id" 
                        draggable="true" @dragstart="onDragStart(idx)" @dragover.prevent="onDragOver(idx)" @dragleave="onDragLeave" @drop.stop="onDrop(idx)" @click="selectArchive(idx)"
                        :class="['group p-3 cursor-grab active:cursor-grabbing border-b border-white/5 archive-item', selectedIdx === idx ? 'active-specimen' : 'opacity-60', dragIdx === idx ? 'dragging' : '', dragOverIdx === idx ? 'drag-over' : '']">
                        <div class="flex justify-between items-start mb-1 pointer-events-none">
                            <span class="text-[9px] font-mono text-indigo-400">{{ idx + 1 }}.</span>
                            <div class="flex gap-2">
                                <span class="text-[8px] font-mono text-slate-500">{{ item.duration.toFixed(1) }}s</span>
                                <button @click.stop="discardArchive(idx)" class="pointer-events-auto text-red-500 hover:text-red-400 transition-opacity p-1">
                                    <i data-lucide="trash-2" class="w-3 h-3"></i>
                                </button>
                            </div>
                        </div>
                        <div class="text-[11px] font-bold truncate pr-6 text-slate-200 pointer-events-none">{{ item.name }}</div>
                    </div>
                </div>

                <div class="p-4 bg-black/40 border-t border-white/5">
                    <div @dragover.prevent="isDraggingFile = true" @dragenter.prevent="isDraggingFile = true" @dragleave.prevent="isDraggingFile = false" @drop.prevent.stop="handleFileDrop"
                        :class="['w-full h-16 border-2 border-dashed border-white/10 rounded-lg flex items-center justify-center gap-3 transition-all', isDraggingFile ? 'bg-indigo-600/20 border-indigo-500 shadow-inner' : '']">
                        <i data-lucide="upload-cloud" :class="['w-4 h-4', isDraggingFile ? 'text-indigo-400 animate-bounce' : 'text-slate-600']"></i>
                        <p class="text-[8px] font-black text-slate-500 uppercase tracking-widest">{{ isDraggingFile ? t.dropRelease : t.dropFile }}</p>
                    </div>
                </div>
            </aside>

            <!-- Parameters -->
            <section class="lg:col-span-6 flex flex-col relative h-[calc(100vh-65px)] overflow-hidden">
                <div class="h-32 bg-black/60 relative flex items-center justify-center overflow-hidden border-b border-white/10">
                    <canvas id="visualizer" class="w-full h-full opacity-80"></canvas>
                    <div class="absolute inset-0 bg-gradient-to-t from-black/40 to-transparent pointer-events-none"></div>
                </div>

                <div class="flex-1 p-6 glass-panel space-y-8 overflow-y-auto">
                    <div class="flex items-center justify-between">
                         <div class="space-y-1">
                            <h2 class="text-[10px] font-black text-indigo-400 uppercase tracking-[0.3em] flex items-center gap-2">
                                <i data-lucide="sliders" class="w-3 h-3"></i> {{ t.paramsTitle }}
                            </h2>
                            <p class="text-[9px] text-slate-500 uppercase font-mono">HASH: {{ seedDisplay }}</p>
                         </div>
                         <div class="flex gap-2">
                             <button @click="toggleReverse" :class="['px-4 py-2 rounded-lg border text-[9px] font-black transition-all', params.reverse ? 'bg-indigo-500 border-indigo-400 text-white' : 'bg-slate-900 border-white/5 text-slate-500']">{{ t.reverseBtn }}</button>
                             <button @click="resetParams" class="px-4 py-2 bg-slate-900 border border-white/5 rounded-lg text-[9px] font-black text-slate-400 hover:text-white transition-all">{{ t.initBtn }}</button>
                         </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-6">
                        <div v-for="config in parameterConfigs" :key="config.key" class="group space-y-2">
                            <div class="flex justify-between items-center">
                                <span class="text-[10px] font-bold text-slate-400 group-hover:text-indigo-400 transition-colors uppercase tracking-[0.2em] flex items-center gap-3">
                                    <i :data-lucide="config.icon" class="w-4 h-4 opacity-50"></i> {{ t[config.key] }}
                                </span>
                                <span class="text-[11px] font-mono text-indigo-400 bg-indigo-500/10 px-2 py-0.5 rounded">{{ formatVal(config.key) }}</span>
                            </div>
                            <input type="range" :min="config.min" :max="config.max" :step="config.step" v-model.number="params[config.key]" @input="onParamInput(config.key)" class="w-full">
                        </div>
                        
                        <div class="group space-y-2 col-span-1 md:col-span-2 pt-4 border-t border-white/5">
                            <div class="flex justify-between items-center">
                                <span class="text-[10px] font-bold text-emerald-500 uppercase tracking-[0.2em] flex items-center gap-3">
                                    <i data-lucide="clock" class="w-4 h-4 opacity-50"></i> {{ t.loopSilence }}
                                </span>
                                <span class="text-[11px] font-mono text-emerald-400 bg-emerald-500/10 px-2 py-0.5 rounded">{{ loopSilence.toFixed(1) }}s</span>
                            </div>
                            <input type="range" min="0" max="10" step="0.1" v-model.number="loopSilence" class="w-full">
                        </div>
                    </div>

                    <div class="pt-4 border-t border-white/5">
                        <div class="bg-indigo-500/5 border border-indigo-500/20 rounded-xl p-4 flex items-center gap-4">
                            <div class="p-2 bg-indigo-500/20 rounded-lg"><i data-lucide="info" class="w-4 h-4 text-indigo-400"></i></div>
                            <p class="text-[10px] text-slate-400 leading-relaxed uppercase tracking-wider" v-html="t.proTip"></p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Controls -->
            <aside class="lg:col-span-3 border-l border-white/5 flex flex-col bg-slate-900/20 h-[calc(100vh-65px)] overflow-hidden">
                <div class="p-6 space-y-6 flex-1 overflow-y-auto">
                    <div class="text-center space-y-4">
                        <h2 class="text-[10px] font-black text-slate-500 uppercase tracking-[0.4em]">{{ t.seedTitle }}</h2>
                        <input type="text" v-model="seedDisplay" @input="onSeedInput" class="w-full bg-black/40 border border-white/5 rounded-2xl p-4 text-center font-mono text-xl font-black text-indigo-400 focus:outline-none focus:border-indigo-500/50 transition-all">
                        <button @click="generateNewSeed" class="w-full py-2 text-[10px] font-black text-indigo-400/60 hover:text-indigo-400 uppercase tracking-widest">{{ t.randomSeedBtn }}</button>
                    </div>

                    <div class="space-y-3 pt-6 border-t border-white/5">
                        <div class="flex gap-2">
                             <button @click="isGenerating ? stopAudio() : startAudio()" :disabled="!audioBuffer || isSequenceMode" 
                                :class="['flex-1 py-5 rounded-2xl font-black text-xs tracking-widest uppercase transition-all flex items-center justify-center gap-3', 
                                isGenerating ? 'bg-red-500 text-white shadow-[0_0_20px_rgba(239,68,68,0.3)]' : 'bg-indigo-600 text-white hover:bg-indigo-500 shadow-[0_4px_0_rgb(55,48,163)] active:shadow-none active:translate-y-1',
                                (!audioBuffer || isSequenceMode) ? 'opacity-20 cursor-not-allowed grayscale' : '']">
                                <i :data-lucide="isGenerating ? 'square' : 'play'" class="w-4 h-4"></i>
                                {{ isGenerating ? t.stopBtn : t.generateBtn }}
                            </button>
                            <button @click="singleLoop = !singleLoop" :disabled="isSequenceMode"
                                :class="['px-5 rounded-2xl border font-black text-[9px] transition-all', singleLoop ? 'bg-indigo-500 border-indigo-400 text-white shadow-lg' : 'bg-slate-900 border-white/10 text-slate-500']">
                                <i data-lucide="repeat" class="w-4 h-4"></i>
                            </button>
                        </div>

                        <div class="space-y-2">
                             <div class="flex gap-1">
                                <button @click="isSequenceMode ? stopSequence() : startSequence(false)" :disabled="archives.length < 1 || isGenerating"
                                    :class="['flex-1 py-4 rounded-l-2xl font-black text-[10px] tracking-widest uppercase transition-all flex flex-col items-center justify-center gap-1 border-y border-l',
                                    (isSequenceMode && !isRecording) ? 'bg-amber-500 text-white border-amber-400' : 'bg-slate-900 border-white/10 text-amber-500 hover:bg-amber-500/10',
                                    (archives.length < 1 || isGenerating) ? 'opacity-20 cursor-not-allowed' : '']">
                                    <i :data-lucide="(isSequenceMode && !isRecording) ? 'square' : 'play-circle'" class="w-4 h-4"></i>
                                    <span>{{ isSequenceMode && !isRecording ? t.stopBtn : t.previewBtn }}</span>
                                </button>
                                <button @click="isSequenceMode ? stopSequence() : startSequence(true)" :disabled="archives.length < 1 || isGenerating"
                                    :class="['flex-1 py-4 rounded-r-2xl font-black text-[10px] tracking-widest uppercase transition-all flex flex-col items-center justify-center gap-1 border',
                                    (isSequenceMode && isRecording) ? 'bg-red-500 text-white border-red-400' : 'bg-slate-900 border-white/10 text-red-500 hover:bg-red-500/10',
                                    (archives.length < 1 || isGenerating) ? 'opacity-20 cursor-not-allowed' : '']">
                                    <i :data-lucide="(isSequenceMode && isRecording) ? 'square' : 'save'" class="w-4 h-4"></i>
                                    <span>{{ isSequenceMode && isRecording ? t.stopBtn : t.renderBtn }}</span>
                                </button>
                                <button @click="sequenceLoop = !sequenceLoop" :disabled="isGenerating"
                                    :class="['px-4 rounded-2xl border font-black text-[9px] transition-all ml-1', sequenceLoop ? 'bg-indigo-500 border-indigo-400 text-white shadow-lg' : 'bg-slate-900 border-white/10 text-slate-500']">
                                    <i data-lucide="repeat-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>

                        <button @click="toggleRecording" :disabled="!isGenerating"
                            :class="['w-full py-3 rounded-xl font-black text-[10px] tracking-widest uppercase transition-all flex items-center justify-center gap-3',
                            isRecording && !isSequenceMode ? 'bg-red-600/20 text-red-400 border border-red-500/50' : 'bg-slate-900 border border-white/10 text-slate-400 hover:text-white',
                            (!isGenerating || isSequenceMode) ? 'opacity-20' : '']">
                            <i data-lucide="circle" :class="['w-3 h-3', isRecording ? 'fill-red-500 text-red-500' : '']"></i>
                            {{ isRecording && !isSequenceMode ? t.recActive : t.manualRec }}
                        </button>
                    </div>

                    <div class="pt-6 border-t border-white/5 space-y-4">
                        <h3 class="text-[9px] font-black text-slate-500 uppercase tracking-widest text-center">{{ t.statusMonitor }}</h3>
                        <div class="grid grid-cols-2 gap-2">
                             <div class="bg-black/30 p-2 rounded border border-white/5 text-center">
                                <p class="text-[8px] text-slate-500 mb-1">{{ t.poolSize }}</p>
                                <p class="text-xs font-mono text-indigo-400">{{ archives.length }}</p>
                             </div>
                             <div class="bg-black/30 p-2 rounded border border-white/5 text-center">
                                <p class="text-[8px] text-slate-500 mb-1">{{ t.totalDur }}</p>
                                <p class="text-xs font-mono text-emerald-400">{{ totalDuration }}s</p>
                             </div>
                        </div>
                    </div>
                </div>

                <div class="p-4 border-t border-white/5 text-center flex justify-between items-center bg-black/40">
                    <p class="text-[8px] text-slate-600 font-mono tracking-widest uppercase">v4.1.17 ARCHIVE REVISION</p>
                    <div class="flex gap-3">
                        <i data-lucide="cpu" class="w-3 h-3 text-slate-700"></i>
                        <i data-lucide="wifi" class="w-3 h-3 text-emerald-500"></i>
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, nextTick } = Vue;

        const i18n = {
            en: {
                subtitle: "Synchronous Temporal Engine",
                seqRender: "SEQ RENDER",
                seqPreview: "SEQ PREVIEW",
                archiveTitle: "Specimen Archive (Drag to Sort)",
                ambientLayer: "Ambient Background",
                addAmbientBtn: "ADD AMBIENT SOUND (OR DROP)",
                importBtn: "IMPORT",
                liveMicBtn: "LIVE REC",
                stopMicBtn: "STOP",
                noSpecimen: "No audio specimens detected",
                dropFile: "Drop File",
                dropRelease: "Release",
                paramsTitle: "Temporal & Spectral Sync",
                reverseBtn: "REVERSE",
                initBtn: "INIT",
                pitch: "Pitch Shift", speed: "Playback Speed", gender: "Formant Control", emotion: "Spectral Brillance",
                echo: "Echo Intensity", volume: "Output Volume", pan: "Stereo Pan", bitcrush: "Signal Decimation",
                loopSilence: "Interval Silence",
                proTip: "<span class='text-white font-bold'>PRO TIP:</span> Adjust parameters real-time. Use 'Personality Seed' for replicable results across nodes.",
                seedTitle: "Personality Seed",
                randomSeedBtn: "RANDOMIZE SEED",
                generateBtn: "GENERATE", stopBtn: "STOP", previewBtn: "PREVIEW", renderBtn: "RENDER",
                manualRec: "MANUAL REC", recActive: "REC ACTIVE",
                statusMonitor: "Status Monitor", poolSize: "POOL SIZE", totalDur: "DURATION"
            },
            jp: {
                subtitle: "時間・スペクトル同期型エンジン",
                seqRender: "録音レンダリング中",
                seqPreview: "プレビュー再生中",
                archiveTitle: "検体アーカイブ（ドラッグで順序変更）",
                ambientLayer: "環境音（バックグラウンド）",
                addAmbientBtn: "環境音を追加（またはドロップ）",
                importBtn: "読込",
                liveMicBtn: "マイク録音",
                stopMicBtn: "終了",
                noSpecimen: "音声検体が読み込まれていません",
                dropFile: "ファイルをドロップ",
                dropRelease: "ここにドロップ",
                paramsTitle: "時間的・スペクトル同期 (8-Param)",
                reverseBtn: "逆再生",
                initBtn: "初期化",
                pitch: "ピッチシフト", speed: "再生速度", gender: "フォルマント制御", emotion: "スペクトル明瞭度",
                echo: "エコー強度", volume: "出力音量", pan: "ステレオ定位", bitcrush: "ビットクラッシュ",
                loopSilence: "ループ間隔（秒）",
                proTip: "<span class='text-white font-bold'>ヒント:</span> パラメータはリアルタイムに反映されます。『性格シード値』を用いることで、異なるノード間でも同一の出力を再現可能です。",
                seedTitle: "性格シード値",
                randomSeedBtn: "シード値をランダム化",
                generateBtn: "再生開始", stopBtn: "停止", previewBtn: "確認再生", renderBtn: "書き出し",
                manualRec: "手動録音", recActive: "録音中",
                statusMonitor: "ステータスモニター", poolSize: "アーカイブ数", totalDur: "合計時間"
            }
        };

        createApp({
            setup() {
                const lang = ref('jp');
                const t = computed(() => i18n[lang.value]);

                const NEUTRAL_PARAMS = { 
                    pitch: 1.0, speed: 1.0, gender: 50, emotion: 50, 
                    echo: 0, volume: 80, pan: 0, bitcrush: 0, reverse: false 
                };
                
                const archives = ref([]);
                const selectedIdx = ref(-1);
                const params = ref({...NEUTRAL_PARAMS});
                const seedDisplay = ref("0000000000");
                const isGenerating = ref(false);
                const isSequenceMode = ref(false);
                const singleLoop = ref(true);
                const sequenceLoop = ref(false);
                const audioBuffer = ref(null);
                const isDraggingFile = ref(false);
                const isDraggingAmbient = ref(false);
                const loopSilence = ref(1.0); 
                
                const ambientBuffer = ref(null);
                const ambientName = ref("");
                const ambientVolume = ref(40);
                const isAmbientPlaying = ref(false);
                let ambientSource = null;
                let ambientGain = null;

                const dragIdx = ref(null);
                const dragOverIdx = ref(null);
                const isRecording = ref(false);
                const isMicSampling = ref(false);
                const micStatus = ref("IDLE");
                
                let audioCtx = null;
                let analyzer = null;
                let masterBus = null;
                let streamDest = null;
                let echoDelay = null, echoFeedback = null, echoGain = null;
                let nodes = { source: null, body: null, bright: null, gain: null, panner: null };
                let loopTimer = null;
                let currentSequenceIdx = 0;
                let mediaRecorder = null;
                let micRecorder = null;
                let recordedChunks = [];
                let micChunks = [];

                const parameterConfigs = [
                    { key: 'pitch', min: 0.5, max: 2.0, step: 0.01, icon: 'activity' },
                    { key: 'speed', min: 0.5, max: 2.0, step: 0.01, icon: 'timer' },
                    { key: 'gender', min: 0, max: 100, step: 1, icon: 'user' },
                    { key: 'emotion', min: 0, max: 100, step: 1, icon: 'sun' },
                    { key: 'echo', min: 0, max: 100, step: 1, icon: 'layers' },
                    { key: 'bitcrush', min: 0, max: 100, step: 1, icon: 'zap' },
                    { key: 'volume', min: 0, max: 100, step: 1, icon: 'volume-2' },
                    { key: 'pan', min: -1.0, max: 1.0, step: 0.01, icon: 'columns' },
                ];

                const totalDuration = computed(() => archives.value.reduce((acc, item) => acc + item.duration, 0).toFixed(1));

                onMounted(() => {
                    lucide.createIcons();
                    initVisualizer();
                });

                const initAudioCtx = () => {
                    if (audioCtx) return;
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    masterBus = audioCtx.createGain();
                    analyzer = audioCtx.createAnalyser();
                    analyzer.fftSize = 256;
                    echoDelay = audioCtx.createDelay();
                    echoDelay.delayTime.value = 0.3;
                    echoFeedback = audioCtx.createGain();
                    echoFeedback.gain.value = 0.4;
                    echoGain = audioCtx.createGain();
                    echoGain.gain.value = 0;
                    
                    masterBus.connect(echoDelay);
                    echoDelay.connect(echoFeedback);
                    echoFeedback.connect(echoDelay);
                    echoDelay.connect(echoGain);
                    echoGain.connect(analyzer);
                    masterBus.connect(analyzer);
                    analyzer.connect(audioCtx.destination);
                    streamDest = audioCtx.createMediaStreamDestination();
                    analyzer.connect(streamDest);
                };

                const handleAmbientUpload = (e) => { processAmbientFile(e.target.files[0]); };
                const handleAmbientDrop = (e) => { 
                    isDraggingAmbient.value = false; 
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('audio/')) processAmbientFile(file);
                };

                const processAmbientFile = async (file) => {
                    if (!file) return;
                    initAudioCtx();
                    ambientName.value = file.name;
                    const buffer = await file.arrayBuffer();
                    audioCtx.decodeAudioData(buffer).then(decoded => {
                        ambientBuffer.value = decoded;
                        startAmbient();
                        nextTick(() => lucide.createIcons());
                    });
                };

                const startAmbient = () => {
                    if (!ambientBuffer.value || !audioCtx) return;
                    stopAmbientInstance();
                    ambientSource = audioCtx.createBufferSource();
                    ambientSource.buffer = ambientBuffer.value;
                    ambientSource.loop = true;
                    ambientGain = audioCtx.createGain();
                    ambientGain.gain.value = ambientVolume.value / 100;
                    ambientSource.connect(ambientGain);
                    ambientGain.connect(analyzer);
                    ambientSource.start();
                    isAmbientPlaying.value = true;
                };

                const stopAmbientInstance = () => {
                    if (ambientSource) { try { ambientSource.stop(); } catch(e) {} }
                };

                const toggleAmbient = () => {
                    if (isAmbientPlaying.value) {
                        stopAmbientInstance();
                        isAmbientPlaying.value = false;
                    } else {
                        startAmbient();
                    }
                };

                const updateAmbientVolume = () => {
                    if (ambientGain) ambientGain.gain.setTargetAtTime(ambientVolume.value / 100, audioCtx.currentTime, 0.05);
                };

                const clearAmbient = () => {
                    stopAmbientInstance();
                    ambientBuffer.value = null;
                    ambientName.value = "";
                    isAmbientPlaying.value = false;
                };

                const initVisualizer = () => {
                    const canvas = document.getElementById('visualizer');
                    const ctx = canvas.getContext('2d');
                    const draw = () => {
                        requestAnimationFrame(draw);
                        if (!analyzer) return;
                        const bufferLength = analyzer.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        analyzer.getByteFrequencyData(dataArray);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        for(let i = 0; i < bufferLength; i++) {
                            const barHeight = (dataArray[i] / 255) * canvas.height;
                            ctx.fillStyle = `rgba(99, 102, 241, ${dataArray[i]/255})`;
                            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                            x += barWidth + 1;
                        }
                    };
                    draw();
                };

                const handleFileUpload = async (e) => {
                    const files = Array.from(e.target.files);
                    for (const file of files) await addFileToArchive(file);
                };

                const handleFileDrop = async (e) => {
                    isDraggingFile.value = false;
                    const files = Array.from(e.dataTransfer.files);
                    for (const file of files) if (file.type.startsWith('audio/')) await addFileToArchive(file);
                };

                const addFileToArchive = async (file) => {
                    initAudioCtx();
                    const buffer = await file.arrayBuffer();
                    const decoded = await audioCtx.decodeAudioData(buffer);
                    archives.value.push({
                        id: crypto.randomUUID(),
                        name: file.name,
                        duration: decoded.duration,
                        buffer: decoded
                    });
                    if (selectedIdx.value === -1) selectArchive(archives.value.length - 1);
                };

                const selectArchive = (idx) => {
                    selectedIdx.value = idx;
                    audioBuffer.value = archives.value[idx].buffer;
                };

                const discardArchive = (idx) => {
                    archives.value.splice(idx, 1);
                    if (selectedIdx.value >= archives.value.length) selectedIdx.value = archives.value.length - 1;
                    if (archives.value.length === 0) {
                        selectedIdx.value = -1;
                        audioBuffer.value = null;
                    } else {
                        selectArchive(selectedIdx.value);
                    }
                };

                const onDragStart = (idx) => { dragIdx.value = idx; };
                const onDragOver = (idx) => { dragOverIdx.value = idx; };
                const onDragLeave = () => { dragOverIdx.value = null; };
                const onDrop = (idx) => {
                    if (dragIdx.value === null) return;
                    const item = archives.value.splice(dragIdx.value, 1)[0];
                    archives.value.splice(idx, 0, item);
                    selectedIdx.value = idx;
                    dragIdx.value = null;
                    dragOverIdx.value = null;
                };
                const onArchiveListDrop = (e) => {
                    if (dragIdx.value !== null && dragOverIdx.value === null) {
                        const item = archives.value.splice(dragIdx.value, 1)[0];
                        archives.value.push(item);
                        selectedIdx.value = archives.value.length - 1;
                        dragIdx.value = null;
                    }
                };

                const startAudio = () => {
                    if (!audioBuffer.value || isGenerating.value) return;
                    initAudioCtx();
                    isGenerating.value = true;
                    playBuffer(audioBuffer.value);
                };

                const playBuffer = (buffer) => {
                    if (!audioCtx) return;
                    
                    nodes.source = audioCtx.createBufferSource();
                    let finalBuffer = buffer;
                    if (params.value.reverse) {
                        const revBuf = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
                        for (let i = 0; i < buffer.numberOfChannels; i++) {
                            const chan = buffer.getChannelData(i);
                            const revChan = revBuf.getChannelData(i);
                            for (let j = 0; j < buffer.length; j++) revChan[j] = chan[buffer.length - 1 - j];
                        }
                        finalBuffer = revBuf;
                    }
                    nodes.source.buffer = finalBuffer;
                    nodes.source.playbackRate.value = params.value.speed;
                    nodes.source.detune.value = (params.value.pitch - 1.0) * 1200;

                    nodes.body = audioCtx.createBiquadFilter();
                    nodes.body.type = "lowpass";
                    nodes.body.frequency.value = 500 + (params.value.gender * 40);

                    nodes.bright = audioCtx.createBiquadFilter();
                    nodes.bright.type = "highshelf";
                    nodes.bright.frequency.value = 3000;
                    nodes.bright.gain.value = (params.value.emotion - 50) * 0.4;

                    nodes.gain = audioCtx.createGain();
                    nodes.gain.gain.value = params.value.volume / 100;

                    nodes.panner = audioCtx.createStereoPanner();
                    nodes.panner.pan.value = params.value.pan;

                    nodes.source.connect(nodes.body);
                    nodes.body.connect(nodes.bright);
                    nodes.bright.connect(nodes.panner);
                    nodes.panner.connect(nodes.gain);
                    nodes.gain.connect(masterBus);

                    echoGain.gain.setTargetAtTime(params.value.echo / 150, audioCtx.currentTime, 0.1);

                    nodes.source.start();
                    nodes.source.onended = () => {
                        if (singleLoop.value && isGenerating.value && !isSequenceMode.value) {
                            loopTimer = setTimeout(startAudio, loopSilence.value * 1000);
                        } else if (isSequenceMode.value) {
                            advanceSequence();
                        } else {
                            stopAudio();
                        }
                    };
                };

                const stopAudio = () => {
                    isGenerating.value = false;
                    clearTimeout(loopTimer);
                    if (nodes.source) { try { nodes.source.stop(); } catch(e) {} }
                };

                const startSequence = (withRecord = false) => {
                    if (archives.value.length === 0) return;
                    initAudioCtx();
                    isSequenceMode.value = true;
                    currentSequenceIdx = 0;
                    if (withRecord) startRecording();
                    playNextInSequence();
                };

                const playNextInSequence = () => {
                    if (!isSequenceMode.value) return;
                    selectArchive(currentSequenceIdx);
                    playBuffer(audioBuffer.value);
                };

                const advanceSequence = () => {
                    currentSequenceIdx++;
                    if (currentSequenceIdx >= archives.value.length) {
                        if (sequenceLoop.value) {
                            currentSequenceIdx = 0;
                            loopTimer = setTimeout(playNextInSequence, loopSilence.value * 1000);
                        } else {
                            stopSequence();
                        }
                    } else {
                        loopTimer = setTimeout(playNextInSequence, loopSilence.value * 1000);
                    }
                };

                const stopSequence = () => {
                    isSequenceMode.value = false;
                    stopAudio();
                    if (isRecording.value) stopRecording();
                };

                const startRecording = () => {
                    recordedChunks = [];
                    const stream = streamDest.stream;
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                    mediaRecorder.onstop = saveRecording;
                    mediaRecorder.start();
                    isRecording.value = true;
                };

                const stopRecording = () => {
                    if (mediaRecorder && isRecording.value) {
                        mediaRecorder.stop();
                        isRecording.value = false;
                    }
                };

                const toggleRecording = () => {
                    if (isRecording.value) stopRecording(); else startRecording();
                };

                const saveRecording = () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `genesis_export_${Date.now()}.webm`;
                    a.click();
                };

                const toggleLiveMic = async () => {
                    if (isMicSampling.value) {
                        stopMic();
                    } else {
                        startMic();
                    }
                };

                const startMic = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        micStatus.value = "SAMPLING";
                        isMicSampling.value = true;
                        micChunks = [];
                        micRecorder = new MediaRecorder(stream);
                        micRecorder.ondataavailable = (e) => micChunks.push(e.data);
                        micRecorder.onstop = async () => {
                            const blob = new Blob(micChunks, { type: 'audio/webm' });
                            const file = new File([blob], `mic_sample_${Date.now()}.webm`, { type: 'audio/webm' });
                            await addFileToArchive(file);
                            stream.getTracks().forEach(t => t.stop());
                        };
                        micRecorder.start();
                        nextTick(() => lucide.createIcons());
                    } catch (e) {
                        micStatus.value = "ERROR";
                    }
                };

                const stopMic = () => {
                    if (micRecorder) micRecorder.stop();
                    isMicSampling.value = false;
                    micStatus.value = "IDLE";
                    nextTick(() => lucide.createIcons());
                };

                const resetParams = () => { params.value = {...NEUTRAL_PARAMS}; };
                const toggleReverse = () => { params.value.reverse = !params.value.reverse; };
                const formatVal = (key) => {
                    if (key === 'pan') return params.value[key] > 0 ? 'R'+params.value[key] : (params.value[key] < 0 ? 'L'+Math.abs(params.value[key]) : 'C');
                    if (['pitch', 'speed'].includes(key)) return params.value[key].toFixed(2) + 'x';
                    return params.value[key];
                };

                const onParamInput = (key) => {
                    if (!nodes.source) return;
                    if (key === 'speed') nodes.source.playbackRate.setTargetAtTime(params.value.speed, audioCtx.currentTime, 0.1);
                    if (key === 'pitch') nodes.source.detune.setTargetAtTime((params.value.pitch - 1.0) * 1200, audioCtx.currentTime, 0.1);
                    if (key === 'gender') nodes.body.frequency.setTargetAtTime(500 + (params.value.gender * 40), audioCtx.currentTime, 0.1);
                    if (key === 'emotion') nodes.bright.gain.setTargetAtTime((params.value.emotion - 50) * 0.4, audioCtx.currentTime, 0.1);
                    if (key === 'volume') nodes.gain.gain.setTargetAtTime(params.value.volume / 100, audioCtx.currentTime, 0.1);
                    if (key === 'pan') nodes.panner.pan.setTargetAtTime(params.value.pan, audioCtx.currentTime, 0.1);
                    if (key === 'echo') echoGain.gain.setTargetAtTime(params.value.echo / 150, audioCtx.currentTime, 0.1);
                };

                const onSeedInput = () => {
                    const s = seedDisplay.value;
                    if (s.length >= 8) {
                        const n = parseInt(s.slice(-8), 16) || 0;
                        params.value.pitch = 0.5 + (n % 150) / 100;
                        params.value.speed = 0.5 + ((n >> 4) % 150) / 100;
                        params.value.gender = (n >> 8) % 100;
                        params.value.emotion = (n >> 12) % 100;
                    }
                };

                const generateNewSeed = () => {
                    seedDisplay.value = Math.random().toString(36).substring(2, 12).toUpperCase();
                    onSeedInput();
                };

                return {
                    lang, t, archives, selectedIdx, params, seedDisplay, isGenerating, isSequenceMode,
                    singleLoop, sequenceLoop, audioBuffer, isDraggingFile, isDraggingAmbient, loopSilence,
                    ambientBuffer, ambientName, ambientVolume, isAmbientPlaying, micStatus, isMicSampling,
                    parameterConfigs, totalDuration, dragIdx, dragOverIdx, isRecording,
                    handleFileUpload, handleFileDrop, handleAmbientUpload, handleAmbientDrop,
                    selectArchive, discardArchive, onDragStart, onDragOver, onDragLeave, onDrop, onArchiveListDrop,
                    startAudio, stopAudio, startSequence, stopSequence, toggleRecording, toggleLiveMic,
                    resetParams, toggleReverse, formatVal, onParamInput, onSeedInput, generateNewSeed,
                    toggleAmbient, clearAmbient, updateAmbientVolume
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
